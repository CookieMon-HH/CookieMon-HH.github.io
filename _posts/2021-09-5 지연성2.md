---
title : "지연성2"
categories:
  - Java Flow
# tags:
#  - Javascript
date : 2021-09-06
---


## 결과를 만드는 함수 reduce, take 

reduce,take는 최종적으로 결과를 만드는 함수 (이터러블한 값을 꺼내서 깨트림)  
-> 중간에 연산을 시작하는 역할, take도 축약하고 완성을 지어버리는 성질을 가지고 있기때문에 지연성을 갖게 하기보다는 연산을 이루어지게 하는 것이 좋음     
map, filter 같은 함수는 이터러블한 값의 안쪽에 있는 원소들에게 함수들을 합성해내는 함수
-> 지연성을 가질 수 있음  

왜 reduce, take는 결과를 만드는 함수로 사용하는 것이 좋을까??  

## queryStr 함수 만들기  

객체로부터 url의 querystring을 만드는 함수  

```    

const queryStr = obj => go(
    obj,
    Object.entries,
    map(([k,v]) => k+'='+v),
    reduce((a,b) => a+'&'+b)
);

console.log(queryStr({ limit: 10, offset: 10, type: 'notice'}));

```    

```  
//output
limit=10&offset=10$type=notice  


강의에서는 '${k}=${v}', '${a}&${b}' 이렇게 썼었는데 구글콘솔창에서는 변수 인식을 못했음 (${a}&${b}을 리턴)그래서 +로 수정..   
-> ES6에 Template literals이 나와서 쓸 수 있다는데 구글 콘솔창은 ES6가 아닌가?...

```  

```  
//위의 함수에서 pipe를 이용하면 

const queryStr = pipe(
    Object.entries,
    map(([k,v]) => k+'='+v),
    reduce((a,b) => a+'&'+b)
);

```  



<추가 확인사항>  
왜 obj.entries가 아니라 Object.entries인지?..  
map의 prototype에 entries가 있는게 아니라 map의 constructor에 entries가 있는데 이렇게 써도 되는건가?  


## Array.prototype.join보다 다형성이 높은 join 함수  

Array의 prototype에 있는 join이 아니라 이터러블객체들에 사용할 수 있는 다형성이 높은 join 함수 만들기  
(값들 사이에 특정 seperator를 추가하여 빼내는 함수)  

```  

const join = curry ((sep=',',iter) => 
  reduce((a,b) => a+sep+b, iter));


const queryStr = pipe(
    Object.entries,
    map(([k,v]) => k+'='+v),
    join('&')
);


console.log(queryStr({ limit: 10, offset: 10, type: 'notice'}));

```  

```  
output 

limit=10&offset=10&type=notice
```  
 
* 다음과 같이 array의 prototype의 join은 이터러블 객체를 받을 수 없지만 위의 join 함수는 가능하다.  
 
```  

function *a(){
  yield 10;
  yield 11;
  yield 12;
  yield 13;

log(a().join(','));  //불가능 
log(join(',', a())); //10,11,12,13 출력

```  

* 위의 join 함수는 reduce를 통해 축약했기때문에 이터러블프로토콜을 따르고, 이에 따라 값을 지연할 수 있다.  
* 다음과 같이 map을 L.map으로 바꿔서 값을 지연시켜도 결과를 잘 만들 수 있다.

```  

const queryStr = pipe(
    Object.entries,
    L.map(([k,v]) => k+'='+v),
    join('&')
);

```  

* entries도 새로 만들어서 지연성을 부여  

```  
L.entries = function *(obj) { 
    for(const k in obj) yield [k, obj[k]];
};

const queryStr = pipe(
    L.entries,
    L.map(([k,v]) => k+'='+v),
    join('&')
);

```  

## take, find  

