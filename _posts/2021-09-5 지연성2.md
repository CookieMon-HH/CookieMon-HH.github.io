---
title : "지연성2"
categories:
  - Java Flow
# tags:
#  - Javascript
date : 2021-09-06
---


## 결과를 만드는 함수 reduce, take 

reduce,take는 최종적으로 결과를 만드는 함수 (이터러블한 값을 꺼내서 깨트림)  
-> 중간에 연산을 시작하는 역할, take도 축약하고 완성을 지어버리는 성질을 가지고 있기때문에 지연성을 갖게 하기보다는 연산을 이루어지게 하는 것이 좋음     
map, filter 같은 함수는 이터러블한 값의 안쪽에 있는 원소들에게 함수들을 합성해내는 함수
-> 지연성을 가질 수 있음  

왜 reduce, take는 결과를 만드는 함수로 사용하는 것이 좋을까??  

## queryStr 함수 만들기  

객체로부터 url의 querystring을 만드는 함수  

'''  

const queryStr = obj => go(
    obj,
    Object.entries,
    map(([k,v]) => k+'='+v),
    reduce((a,b) => a+'&'+b)
);

console.log(queryStr({ limit: 10, offset: 10, type: 'notice'}));

'''  

'''  
//output
limit=10&offset=10$type=notice  


강의에서는 '${k}=${v}', '${a}&${b}' 이렇게 썼었는데 구글콘솔창에서는 변수 인식을 못했음 (${a}&${b}을 리턴)그래서 +로 수정..   
-> ES6에 Template literals이 나와서 쓸 수 있다는데 구글 콘솔창은 ES6가 아닌가?...

'''  

'''  
//위의 함수에서 pipe를 이용하면 

const queryStr = pipe(
    Object.entries,
    map(([k,v]) => k+'='+v),
    reduce((a,b) => a+'&'+b)
);

'''  



<추가 확인사항>  
왜 obj.entries가 아니라 Object.entries인지?..  
map의 prototype에 entries가 있는게 아니라 map의 constructor에 entries가 있는데 이렇게 써도 되는건가?  


## Array.prototype.join보다 다형성이 높은 join 함수  



