
### 번들결과 최적화  

* 코드가 많아지면 번들링된 결과물도 커지기 때문에 성능에 영향을 줄 수 있다.  
* 이를 위해 최적화를 할 수 있다.  


### production 모드 이용  

* 운영환경에 적합한 환경 제공 
* 모드를 development로 하면 디버깅 편의를 위해 NamedChunkPlugin, NamedModulesPlugin 두 개의 플러그 인을 사용  
* 반면 production 모드로 설정하면 자바스크립트의 결과물을 최소화하기 위해 7개의 플러그인을 사용한다.  
* 환경변수 NODE_ENV 값에 따라 모드를 설정하도록 웹팩 설정코드를 추가하여 사용할 수 있다.  
* production모드를 이용하면 결과물이 난독화된다.(효율적으로 하기 위한것인듯?)  


### Optimization 속성 사용  

* HtmlWebpackPlugin이 html 파일을 압축한 것 처럼 css파일도 optimize-css-assets-webpack-plugin을 사용하면 압축이 가능하다.  
* 해당 플러그인을 다운로드하고 설정해주면 빈칸을 없애준다.  
* TeserWebpackPlugin : 자바스크립트 코드를 난독화하고 debugger 구문을 제거한다.   
* TeserWebpackPlugin은 기본설정 외에도 콘솔로그를 제거하는 옵션도 있다.(배포환경에는 필요 없으니)  

### 코드 스플리팅  

* 결과물을 여러개로 쪼개 브라우저 다운로드 속도를 높일 수 있다.  

1) 엔트리 분리  

* 두 개의 엔트리포인트를 만들어준다.  
* 엔트리 포인트란 파일을 합치는 시작점이 되는 파일  
* https://velog.io/@jakeseo_me/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EA%B3%B5%EB%B6%80-4-%EC%97%94%ED%8A%B8%EB%A6%AC%EC%95%84%EC%9B%83%ED%92%8B
* 이 중 중복되는 코드를 제거하는 옵션도 사용할 수 있다.(splitChunk)  

2) 다이나믹 임포트  

* 엔트리포인트를 직접 분리하는 것은 손이 많이감  
* 다이나믹 임포트를 사용하면 자동화 할 수 있음  
* chunkname을 지정해 주면 알아서 만들어준다.  

#### Externals  

* 빌드할 필요가 없는 것들은 대상에서 빼버리는 것  
* axios같은 서드파티 라이브러리는 패키지로 제공될 때 이미 빌드과정을 거쳤기 때문에 빌드 프로세스에서 제외하는 것아 좋다.  
* 빌드된 파일을 복사해주는 설정을 추가로 해줘야 한다.  






